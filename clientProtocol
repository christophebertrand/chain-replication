type message{ID, content, retAddr}

Vars:
  - ToDeliver: Set[message]
  - delivered:  Set[message]
  - activePeers: Set[peer]

Event <'RaftDeliver', msg>
  if msg not in delivered:
    toDeliver += msg
    resp := responsible(msg, activePeers)
    if resp == self:
      sendToClient(msg)

Event <'delivered', msg, from>
  activePeers += from
  toDeliver -= msg
  delivered += msg

Event <'timeout', p: peer>
  activePeers -= p
  for msg := range toDeliver:
    if self == responsible(msg, activePeers):
      sendToClient(msg)

Periodically send heartbeat or piggyback on raft.


def sendToClient(msg):
  httpSend('ok', msg.retAddr) #possible failure here
  delivered += msg
  toDeliver -= msg
  broadcast('delivered', msg)

def responsible(msg, activePeers):
  r := msg.ID % len(activePeers)
  sorted := sort(activePeers)
  return sorted[r].ID

def crashRecovery:
  ToDeliver, delivered = askPeer for their state

# optimization maybe possible with msg IDs to reduced delivered, ID are not continuous
